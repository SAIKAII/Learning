# stl学习笔记
参考书籍《Effective stl》

- vector、string、deque和list被称为标准序列容器。标准关联容器是set、multiset、map和multimap。
- 迭代器有五类：输入迭代器(input iterator)(遍历到的位置上只能被读取一次)、输出迭代器(output iterator)(遍历到的位置上只能被写入一次)、前向迭代器(forward iterator)(可对同一位置重复读写)、双向迭代器(bidirectional iterator)、随机访问迭代器(random access iterator)(有向前向后跳跃能力)。
- 函数子类：重载了函数调用操作符(operator())的类。从这些类创建的对象被称为函数对象(function object)或函数子(functor)。
- 标准的连续内存容器有vector、string和deque。非标准的rope也是一个连续内存容器。
- 表示链表的容器，如list和slist，是基于节点的；所有标准的关联容器也是如此(通常的实现方式是平衡树)。

### 容器的选择
- 如果要在任意位置插入新元素，就选择序列容器。
- 如果关心排序，哈希容器是不可行的。
- 若要随机访问，只能是vector、deque和string。
- 发生元素的插入或删除时，若要避免移动容器中原来的元素，就得避免使用连续内存的容器。
- 考虑查找因素，就要考虑哈希容器、排序的vector和标准关联容器这样的选择顺序。
- 若介意使用引用计数，就要避免使用string。考虑vector<char>取代。
- 对插入和删除操作的事务语义(失败时回滚)，要使用基于节点的容器。只有list对多个元素的插入操作提供了事务语义。对希望编写异常安全(exception-safe)代码的程序员，事务语义显得尤为重要。
- 若要迭代器、指针和引用变为无效的次数最少，就要使用基于节点的容器，因为对这类容器的插入和删除操作从来不会使迭代器、指针和引用变为无效(除非它们指向了一个你正在删除的元素)。
- 需要随机访问、尾部**插入**时**指针**和**引用**都**不会**变为无效，选择deque。deque是唯一的**迭代器**可能会变为无效而指针和引用不会变为无效的stl标准容器。

### 确保容器中的对象拷贝正确而高效
- 当通过如insert或push_back之类的操作向容器中加入对象时，存入容器的是你所指定的对象的**拷贝**。取出一个对象时，所得是容器中所保存的对象的**拷贝**。
- 使拷贝动作高效、正确，并防止剥离问题(派生类拷贝给基类)发生的一个简单办法是使容器包含指针而不是对象。也就是使用Widget*的容器，而不是Widget的容器。但是指针又有指针的问题(使用智能指针解决)。

### 调用empty而不是检查size()是否为0
- empty对**所有**的标准容器都是常数时间操作，而对一些list实现，size耗费线性时间。

### 注意C++编译器的分析机制
- `list<int> data(istream_iterator<int>(dataFile), istream_iterator<int>());` 这个其实是声明了一个函数。注意看=>`void f(double (*pf)());`、`void f(double pf());`和`void f(double ());`是一样的，都是一个参数为函数指针的函数声明。`istream_iterator<int> (dataFile)`是一个类型为`istream_iterator<int>`的参数。

### 什么情况下用vector<char>代替string
- 当你程序需要线程安全时，而你所使用的string又是使用了引用计数技术来提高效率，这个时候就需要用vector<char>代替string。

### set和multiset的元素
- set和multiset的元素其实可以修改，不过不能修改会影响排序的那部分(比如一个类作为键值，类中的id字段作为排序规则，其他字段可以任意修改)。但是有一种情况下，元素完全不能修改，就是set<T>::iterator的operator*返回的是一个const T&，也就是说解除了set迭代器的引用之后的结果是一个指向该集合中元素的const引用。
- 但是在一些编译器下是失败的，因为在这些编译器下，操作之后返回的set元素的const类型的，我们需要强制类型转换。使用`const_cast<T&>(*i).opt("...");`。为什么需要转换为**T&** ，而不能是**T**？因为若是不加上**&** 符号，得到的就是一个临时的匿名对象，也就是***i**的结果还是原来那个。而对临时对象操作，并没有什么用。强制类型转换到引用避免了创建新的对象(临时匿名对象)。

### 考虑用排序的vector代替关联容器
- 标准关联容器(如：map)的效率比vector还低的情况并不少见。因为关联容器一般都用到平衡二叉树，对于平衡二叉树，每个节点都有对象自身和大概3个指针(左节点、右节点和父节点)，占用了太多的空间。而vector通常整个结构也就3个指针或2个指针加一个int。当操作系统使用了虚拟内存，则很容易看出关联容器将导致更多的页面错误，从而当数据量很大的时候，系统会显著变慢(比如本来用vector可以一个页面存储，用关联容器却需要两个页面或更多)。
- 当然主要还是得是特殊情况下才如此，不能是插入、删除和查找混合操作，否则就是在浪费时间。
