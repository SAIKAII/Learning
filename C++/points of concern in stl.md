# stl学习笔记
参考书籍《Effective stl》

- vector、string、deque和list被称为标准序列容器。标准关联容器是set、multiset、map和multimap。
- 迭代器有五类：输入迭代器(input iterator)(遍历到的位置上只能被读取一次)、输出迭代器(output iterator)(遍历到的位置上只能被写入一次)、前向迭代器(forward iterator)(可对同一位置重复读写)、双向迭代器(bidirectional iterator)、随机访问迭代器(random access iterator)(有向前向后跳跃能力)。
- 函数子类：重载了函数调用操作符(operator())的类。从这些类创建的对象被称为函数对象(function object)或函数子(functor)。
- 标准的连续内存容器有vector、string和deque。非标准的rope也是一个连续内存容器。
- 表示链表的容器，如list和slist，是基于节点的；所有标准的关联容器也是如此(通常的实现方式是平衡树)。

### 容器的选择
- 如果要在任意位置插入新元素，就选择序列容器。
- 如果关心排序，哈希容器是不可行的。
- 若要随机访问，只能是vector、deque和string。
- 发生元素的插入或删除时，若要避免移动容器中原来的元素，就得避免使用连续内存的容器。
- 考虑查找因素，就要考虑哈希容器、排序的vector和标准关联容器这样的选择顺序。
- 若介意使用引用计数，就要避免使用string。考虑vector<char>取代。
- 对插入和删除操作的事务语义(失败时回滚)，要使用基于节点的容器。只有list对多个元素的插入操作提供了事务语义。对希望编写异常安全(exception-safe)代码的程序员，事务语义显得尤为重要。
- 若要迭代器、指针和引用变为无效的次数最少，就要使用基于节点的容器，因为对这类容器的插入和删除操作从来不会使迭代器、指针和引用变为无效(除非它们指向了一个你正在删除的元素)。
- 需要随机访问、尾部**插入**时**指针**和**引用**都**不会**变为无效，选择deque。deque是唯一的**迭代器**可能会变为无效而指针和引用不会变为无效的stl标准容器。

### 确保容器中的对象拷贝正确而高效
- 当通过如insert或push_back之类的操作向容器中加入对象时，存入容器的是你所指定的对象的**拷贝**。取出一个对象时，所得是容器中所保存的对象的**拷贝**。
- 使拷贝动作高效、正确，并防止剥离问题(派生类拷贝给基类)发生的一个简单办法是使容器包含指针而不是对象。也就是使用Widget*的容器，而不是Widget的容器。但是指针又有指针的问题(使用智能指针解决)。

### 调用empty而不是检查size()是否为0
- empty对**所有**的标准容器都是常数时间操作，而对一些list实现，size耗费线性时间。
