# Redis学习笔记
参考书籍《Redis设计与实现》
## 字符串实现
- Redis没有直接使用C语言传统的字符串表示(以空字符结尾的字符数组)，而是自己构建了一种名为简单动态字符串的抽象类型，并将SDS用作Redis的默认字符串表示。当Redis需要的不仅仅是一个字符串字面量，而是一个可以被修改的字符串值时，Redis就会使用SDS来表示字符串值。例如：set msg “Hello world”，其中的键(msg)和值(Hello world)底层实现都是使用SDS来表示字符串值。
- SDS遵循C字符串以空字符结尾的惯例，保存空字符的1字节空间不计算在SDS的len属性里面，并且为空字符分配额外的1字节空间，以及添加空字符到字符串末尾等操作，都是由SDS函数自动完成的，所以这个空字符对于SDS的使用者来说是完全透明的。遵循空字符结尾这一惯例的好处是，SDS可以直接重用一部分C字符串函数库里面的函数。
- 如果是普通的C字符串，那么每次缩短或扩展字符串长度的时候都需要内存重分配，否则就会造成内存泄露/溢出，但是这是非常耗时的操作，对于频繁修改的数据库来说，是无法忍受的。而SDS则通过空间预分配和惰性空间释放两种优化策略，以提高性能。

## 链表实现
- 链表提供了高效的节点重排能力，以及顺序性的节点访问方式，并且可以通过增删节点来灵活地调整链表的长度。
- 因为C语言没有链表数据结构，所以要自己实现。其中listNode是节点结构体，而list则是链表结构体。Redis的链表实现的特性可以总结如下：
  1. 双端：链表节点带有prev和next指针，获取某个节点的前置节点和后置节点的复杂度都是O(1)
  2. 无环：表头节点的prev指针和表尾节点的next指针都指向NULL，对链表的访问以NULL为终点
  3. 带表头指针和表尾指针：通过list结构的head指针和tail指针，程序获取链表的表头节点和表尾节点的复杂度为O(1)
  4. 带链表长度计数器：程序使用list结构的len属性来对list持有的链表节点进行计数，程序获取链表中节点数量的复杂度为O(1)
  5. 多态：链表节点使用void*指针来保存节点值，并且可以通过list结构的dup、free、match三个属性为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值。

## 字典实现
- 字典，又称为符号表、关联数组或映射，是一种用于保存键值对的抽象数据结构。
- 字典中的每个键都是独一无二的。
- 字典的底层实现其实是哈希表。
- 当有两个或以上数量的键被分配到了哈希表数组的同一个索引上面时，我们称这些键发生了冲突。Redis的哈希表使用链地址法来解决键冲突，每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表链接起来，这就解决了键冲突的问题。
- rehash(重新散列)主要是为了让哈希表的负载因子(load factor)维持在一个合理的范围之内，用于扩展或者收缩哈希表的大小，需要ht[1]的辅助。
- rehash动作并不是一次性、集中式地完成的，而是分多次、渐进式地完成的。
- 因为在进行渐进式rehash的过程中，字典会同时使用ht[0]和ht[1]两个哈希表，所以在渐进式rehash进行期间，字典的删除、查找、更新等操作会在两个哈希表上进行。另外，在渐进式rehash执行期间，新添加到字典的键值对一律会被保存到ht[1]里面，而ht[0]则不再进行任何添加操作。
- 总结：
  1. 字典被广泛用于实现Redis的各种功能，其中包括数据库和哈希键
  2. Redis中的字典使用哈希表作为底层实现，每个字典带有两个哈希表，一个平时使用，一个rehash时使用
  3. 当字典被用作数据库的底层实现，或者哈希键的底层实现时，Redis使用MurmurHash2算法来计算键的哈希值
  4. 哈希表使用链地址法来解决键冲突，被分配到同一个索引上的多个键值对会连接成一个单向链表
  5. 在对哈希表进行扩展或者收缩操作时，程序需要将现有哈希表包含的所有键值对rehash到新哈希表里面，并且这个rehash过程并不是一次性完成的，而是渐进式地完成的

## 跳跃表实现
- 跳跃表是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。
- Redis使用跳跃表作为有序集合键的底层实现之一。
- 总结：
  1. 跳跃表是有序集合的底层实现之一
  2. Redis的跳跃表实现由zskiplist和zskiplistNode两个结构组成，其中zskiplist用于保存跳跃表信息(比如表头节点、表尾节点、长度)，而zskiplistNode则用于表示跳跃表节点
  3. 每个跳跃表节点的层高都是1至32之间的随机数
  4. 在同一个跳跃表中，多个节点可以包含相同的分值，但每个节点的成员对象必须是唯一的
  5. 跳跃表中的节点按照分值大小进行排序，当分值相同时，节点按照成员对象的大小进行排序

## 整数集合实现
- 整数集合是集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis就会使用整数集合作为集合键的底层实现。
- 整数集合是Redis用于保存整数值的集合抽象数据结构，它可以保存类型为int16_t、int32_t或者int64_t的整数值，并且保证集合中不会出现重复元素。
- 每当我们要将一个新元素添加到整数集合里面，并且新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要先进行升级，然后才能将新元素添加到整数集合里面。升级步骤如下：
  1. 根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间
  2. 将底层数组现有的所有元素都转换成与新元素相同的类型，并将类型转换后的元素放置到正确的位上，而且在放置元素的过程中，需要继续维持底层数组的有序性质不变
  3. 将新元素添加到底层数组里面
- 总结：
  1. 整数集合是集合键的底层实现之一
  2. 整数集合的底层实现为数组，这个数组以有序、无重复的方式保存集合元素，在有需要时，程序会根据新添加元素的类型，改变这个数组的类型
  3. 升级操作为整数集合带来了操作上的灵活性，并且尽可能地节约了内存
  4. 整数集合只支持升级操作，不支持降低操作

## 压缩列表实现
- 压缩列表是列表键和哈希键的底层实现之一。当一个列表键只包含少量列表项，并且每个列表项(即”键“的”“值”)要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。另外，当一个哈希键只包含少量键值对，并且每个键值对的键还有值要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做哈希键的底层实现。
- 压缩列表是Redis为了节约内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型数据结构。一个压缩列表可以包含任意多个节点，每个节点可以保存一个字节数组或者一个整数值。
