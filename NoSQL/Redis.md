# Redis学习笔记
参考书籍《Redis设计与实现》
### 字符串实现
Redis没有直接使用C语言传统的字符串表示(以空字符结尾的字符数组)，而是自己构建了一种名为简单动态字符串的抽象类型，并将SDS用作Redis的默认字符串表示。当Redis需要的不仅仅是一个字符串字面量，而是一个可以被修改的字符串值时，Redis就会使用SDS来表示字符串值。例如：set msg “Hello world”，其中的键(msg)和值(Hello world)底层实现都是使用SDS来表示字符串值。

SDS遵循C字符串以空字符结尾的惯例，保存空字符的1字节空间不计算在SDS的len属性里面，并且为空字符分配额外的1字节空间，以及添加空字符到字符串末尾等操作，都是由SDS函数自动完成的，所以这个空字符对于SDS的使用者来说是完全透明的。遵循空字符结尾这一惯例的好处是，SDS可以直接重用一部分C字符串函数库里面的函数。

如果是普通的C字符串，那么每次缩短或扩展字符串长度的时候都需要内存重分配，否则就会造成内存泄露/溢出，但是这是非常耗时的操作，对于频繁修改的数据库来说，是无法忍受的。而SDS则通过空间预分配和惰性空间释放两种优化策略，以提高性能。

### 链表实现
链表提供了高效的节点重排能力，以及顺序性的节点访问方式，并且可以通过增删节点来灵活地调整链表的长度。

因为C语言没有链表数据结构，所以要自己实现。其中listNode是节点结构体，而list则是链表结构体。Redis的链表实现的特性可以总结如下：
1. 双端：链表节点带有prev和next指针，获取某个节点的前置节点和后置节点的复杂度都是O(1)
2. 无环：表头节点的prev指针和表尾节点的next指针都指向NULL，对链表的访问以NULL为终点
3. 带表头指针和表尾指针：通过list结构的head指针和tail指针，程序获取链表的表头节点和表尾节点的复杂度为O(1)
4. 带链表长度计数器：程序使用list结构的len属性来对list持有的链表节点进行计数，程序获取链表中节点数量的复杂度为O(1)
5. 多态：链表节点使用void*指针来保存节点值，并且可以通过list结构的dup、free、match三个属性为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值。

### 字典实现
字典，又称为符号表、关联数组或映射，是一种用于保存键值对的抽象数据结构。

字典中的每个键都是独一无二的。

字典的底层实现其实是哈希表。

当有两个或以上数量的键被分配到了哈希表数组的同一个索引上面时，我们称这些键发生了冲突。Redis的哈希表使用链地址法来解决键冲突，每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表链接起来，这就解决了键冲突的问题。

rehash(重新散列)主要是为了让哈希表的负载因子(load factor)维持在一个合理的范围之内，用于扩展或者收缩哈希表的大小，需要ht[1]的辅助。

rehash动作并不是一次性、集中式地完成的，而是分多次、渐进式地完成的。

因为在进行渐进式rehash的过程中，字典会同时使用ht[0]和ht[1]两个哈希表，所以在渐进式rehash进行期间，字典的删除、查找、更新等操作会在两个哈希表上进行。另外，在渐进式rehash执行期间，新添加到字典的键值对一律会被保存到ht[1]里面，而ht[0]则不再进行任何添加操作。

总结：
1. 字典被广泛用于实现Redis的各种功能，其中包括数据库和哈希键
2. Redis中的字典使用哈希表作为底层实现，每个字典带有两个哈希表，一个平时使用，一个rehash时使用
3. 当字典被用作数据库的底层实现，或者哈希键的底层实现时，Redis使用MurmurHash2算法来计算键的哈希值
4. 哈希表使用链地址法来解决键冲突，被分配到同一个索引上的多个键值对会连接成一个单向链表
5. 在对哈希表进行扩展或者收缩操作时，程序需要将现有哈希表包含的所有键值对rehash到新哈希表里面，并且这个rehash过程并不是一次性完成的，而是渐进式地完成的

### 跳跃表实现
跳跃表是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。

Redis使用跳跃表作为有序集合键的底层实现之一。

总结：
1. 跳跃表是有序集合的底层实现之一
2. Redis的跳跃表实现由zskiplist和zskiplistNode两个结构组成，其中zskiplist用于保存跳跃表信息(比如表头节点、表尾节点、长度)，而zskiplistNode则用于表示跳跃表节点
3. 每个跳跃表节点的层高都是1至32之间的随机数
4. 在同一个跳跃表中，多个节点可以包含相同的分值，但每个节点的成员对象必须是唯一的
5. 跳跃表中的节点按照分值大小进行排序，当分值相同时，节点按照成员对象的大小进行排序

### 整数集合实现
整数集合是集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis就会使用整数集合作为集合键的底层实现。

整数集合是Redis用于保存整数值的集合抽象数据结构，它可以保存类型为int16_t、int32_t或者int64_t的整数值，并且保证集合中不会出现重复元素。

每当我们要将一个新元素添加到整数集合里面，并且新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要先进行升级，然后才能将新元素添加到整数集合里面。升级步骤如下：
1. 根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间
2. 将底层数组现有的所有元素都转换成与新元素相同的类型，并将类型转换后的元素放置到正确的位上，而且在放置元素的过程中，需要继续维持底层数组的有序性质不变
3. 将新元素添加到底层数组里面

总结：
1. 整数集合是集合键的底层实现之一
2. 整数集合的底层实现为数组，这个数组以有序、无重复的方式保存集合元素，在有需要时，程序会根据新添加元素的类型，改变这个数组的类型
3. 升级操作为整数集合带来了操作上的灵活性，并且尽可能地节约了内存
4. 整数集合只支持升级操作，不支持降低操作

### 压缩列表实现
压缩列表是列表键和哈希键的底层实现之一。当一个列表键只包含少量列表项，并且每个列表项(即“键”的“值”)要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。另外，当一个哈希键只包含少量键值对，并且每个键值对的键还有值要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做哈希键的底层实现。

压缩列表是Redis为了节约内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型数据结构。一个压缩列表可以包含任意多个节点，每个节点可以保存一个字节数组或者一个整数值。

总结：
1. 压缩列表是一种为节约内存而开发的顺序型数据结构
2. 压缩列表被用作列表键和哈希键的底层实现之一
3. 压缩列表可以包含多个节点，每个节点可以保存一个字节数组或者整数值
4. 添加新节点到压缩列表，或者从压缩列表中删除节点，可能会引发连锁更新操作，但这种操作出现的几率不高

### 对象
Redis并没有直接使用前面介绍的数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统，这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五中类型的对象，每种对象都用到了**至少**一种我们前面所介绍的数据结构。

Redis的对象系统实现了基于引用计数技术的内存回收机制，当程序不再使用某个对象的时候，这个对象所占用的内存就会被自动释放；另外，Redis还通过引用计数技术实现了对象共享机制，这一机制可以在适当的条件下，通过让多个数据库键共享同一个对象来节约内存。

Redis对象带有访问时间记录信息，该信息可以用于计算数据库键的空转时长，在服务器启用了maxmemory功能的情况下，空转时长较大的那些键可能会优先被服务器删除。

每个对象都有一个结构体(redisObject)
```C
typedef struct redisObject{
    unsigned type:4;
    unsigned encoding:4;
    // lru time (relative to server.lruclock)
    unsigned lru:REDIS_LRU_BITS;
    int refcount;
    void* ptr;
}robj;
```

### 字符串对象
字符串对象的编码可以是int、raw(字符串大于32字节)或者embstr(小于32字节)。

如果一个字符串保存的是整数值，并且这个整数值可以用long类型来表示，那么字符串对象会将整数值保存在字符串对象结构的ptr属性里面(void*转换成long)，并将字符串对象的编码设置为int。

raw编码会调用两次内存分配函数来分别创建redisObject结构和sdshdr结构，而embstr编码则通过调用一次内存分配函数来分配一块连续的空间，空间中依次包含redisObject和sdshdr两个结构。

使用embstr编码的字符串对象来保存短字符串值好处如下：
1. embstr编码将创建字符串对象所需的内存分配次数从raw编码的两次降低为一次
2. 释放embstr编码的字符串对象只需调用一次内存释放函数，而释放raw编码的字符串对象需要调用两次内存释放函数
3. 因为embstr编码的字符串对象的所有数据都保存在一块连续的内存里面，所以这种编码的字符串对象比起raw编码的字符串对象能够更好地利用缓存带来的优势

### 列表对象
列表对象的编码可以是ziplist和linkedlist两种。

编码转换：
1. 列表对象保存的所有字符串元素的长度都小于64字节
2. 列表对象保存的元素数量小于512个；不能满足这两个条件的列表对象需要使用linkedlist编码

### 哈希对象
哈希对象的编码可以是ziplist或者hashtable。

ziplist编码的哈希对象使用压缩列表作为底层实现：
1. 保存了同一键和值的两个节点总是紧挨在一起，保存键的节点在前，保存值的节点在后
2. 先添加到哈希对象中的键值对会被放在压缩列表的表头方向，而后来添加到哈希对象中的键值对会被放在压缩列表的表尾方向

hashtable编码的哈希对象使用字典作为底层实现：
1. 字典的每个键都是一个字符串对象，对象中保存了键值对的键
2. 字典的每个值都是一个字符串对象，对象中保存了键值对的值

编码转换：
1. 哈希对象保存的所有键值对的键和值的字符串长度都小于64字节
2. 哈希对象保存的所有键值对数量小于512个

不能满足这两个条件的哈希对象需要使用hashtable编码。

### 集合对象
集合对象的编码可以是intset或者hashtable。

intset编码的集合对象使用整数集合作为底层实现，集合对象包含的所有元素都被保存在整数集合里面。

hashtable编码的集合对象使用字典作为底层实现，字典的每个键都是一个字符串对象，每个字符串对象包含了一个集合元素，而字典的值则全部被设置为NULL。

编码转换：
1. 集合对象保存的所有元素都是整数值
2. 集合对象保存的元素数量不超过512个

不能满足这两个条件的集合对象需要使用hashtable编码。

### 有序集合对象
有序集合的编码可以是ziplist或者skiplist。

ziplist编码的压缩列表对象使用压缩列表作为底层实现，每个集合元素使用两个挨在一起的压缩列表节点来保存，第一个节点保存元素的成员，而第二个元素则保存元素的分值。压缩列表内的集合按分值从小到大进行排序，分值较小的元素被放置在靠近表头的方向，而分值较大的元素则被放置在靠近表尾的方向。

有序集合的结构体：
```C++
typedef struct zset{
  zskiplist* zsl; //跳跃表
  dict* dict; //字典
};
```
虽然zset结构同时使用跳跃表和字典来保存有序集合元素，但这两种数据结构都会通过指针来共享相同元素的成员和分值，所以同时使用跳跃表和字典来保存集合元素不会产生任何重复成员或者分值，也不会因此而浪费额外的内存。

编码转换：
1. 有序集合保存的元素数量小于128个
2. 有序集合保存的所有元素成员的长度都小于64字节

不能满足以上两个条件的有序集合对象将使用skiplist编码。

### 类型检查与命令多态
命令基本分两种，一种是可以对任何类型的键执行，比如说DEL命令、EXPIRE命令、RENAME命令、TYPE命令、OBJECT命令等。另一种命令只能对特定类型的键执行。

类型特定命令所进行的类型检查是通过redisObject结构的type属性来实现的：
1. 在执行一个类型特定命令之前，服务器会先检查输入数据库键的值对象是否为执行命令所需的类型，如果是的话，服务器就对键执行指定的命令
2. 否则，服务器将拒绝执行命令，并向客户端返回一个类型错误

Redis除了会根据值对象的类型来判断键是否能够执行指定命令之外，还会根据值对象的编码方式，选择正确的命令实现代码来执行命令。(多态)

### 内存回收
由于C语言不具备自动内存回收功能，所以Redis构建了一个引用计数技术来实现内存回收机制。
```C
typedef struct redisObject{
    unsigned type:4;
    unsigned encoding:4;
    unsigned lru:REDIS_LRU_BITS;
    int refcount; //这个
    void* ptr;
}robj;
```

### 对象共享
在Redis中，让多个键共享同一个值对象需要执行以下两个步骤：
1. 将数据库键的值指针指向一个现有的值对象
2. 将被共享的值对象的引用计数增一

### 对象的空转时长
redisObject结构包含一个属性为lru属性，该属性记录了对象最后一次被命令程序访问的时间。

### 服务器中的数据库
Redis服务器将所有数据库都保存在服务器状态redisServer结构的db数组中，db数组的每个项都是一个redisDb结构，每个redisDb结构代表一个数据库：
```C
struct redisServer{
  ...
  //一个数组，保存着服务器中的所有数据库
  redisDb* db;
  //服务器的数据库数量，指定服务器在初始化时应该创建多少个数据库
  int dbnum;
  ...
};
```
在服务器内存，客户端状态redisClient结构的db属性记录了客户端当前的目标数据库，这个属性是一个指向redisDb结构的指针：
```C
typedef struct redisClient{
  ...
  //记录客户端当前正在使用的数据库
  redis* db;
  ...
}redisClient;
```
redisClient.db指针指向redisServer.db数组的其中一个元素，而被指向的元素就是客户端的目标数据库。

### 数据库键空间
服务器中的每个数据库都由一个redisDb结构表示，其中，redisDb结构的dict字典保存了数据库中的所有键值对，我们将这个字典称为键空间：
```C
typedef struct redisDb {
  ...
  //数据库键空间，保存这数据库中的所有键值对
  dict* dict;
  ...
}redisDb;
```

### 添加新键
添加一个新键值对到数据库，实际上就是将一个新键值对添加到键空间字典里面，其中键为字符串对象，而值则为任意一种类型的Redis对象。

### 删除键
删除数据库中的一个键，就是在键空间里面删除键对应的键值对对象。

### 更新键
对一个数据库键进行更新，就是对键空间里面键所对应的值对象进行更新，根据值对象的类型不同，更新的具体方法也会有所不同。

### 对键取值
对一个数据库键进行取值，就是在键空间中去除键所对应的值对象，根据值对象的类型不同，具体的取值方法也会有所不同。

### 设置键的生成时间或过期时间
通过EXPIRE或者PEXPIRE命令，客户端可以以秒或者毫秒精度为数据库中的某个键设置生存时间，在经过指定的秒数或者毫秒数之后，服务器就会自动删除生存时间为0的键。

与EXPIRE或者PEXPIRE命令类型，客户端可以通过EXPIREAT或者PEXPIREAT命令，以秒或者毫秒精度给数据库中的某个键设置过期时间。

TTL或者PTTL命令接受一个带有生存时间或者过期时间的键，返回这个键的剩余生存时间，也就是，返回距离这个键被服务器自动删除还有多长时间。

### 保存过期时间
redisDb结构的expires字典保存了数据库中所有键的过期时间，我们称这个字典为过期字典：
```C
typedef struct redisDb{
  ...
  //过期字典，保存键的过期时间
  dict* expires;
}redisDb;
```
过期字典的键是一个指针，这个指针指向键空间中的某个键对象。过期字典的值是一个long long类型的整数，这个整数保存了键所指向的数据库键的过期时间——一个毫秒精度的UNIX时间戳。

### 移除过期时间
PERSIST命令可以移除一个键的过期时间。

### 过期键删除策略
- 定时删除：在设置键的过期时间的同时，创建一个定时器，让定时器在键的过期时间来临时，立即执行对键的删除操作。
- 惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，就返回该键。
- 定期删除： 每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少隔数据库，则由算法决定。

### RDB持久化
在创建一个新的RDB文件时，程序会对数据库中的键进行检查，**已过期** 的键不会被保存到新创建的RDB文件中。

在启动Redis服务器时，如果服务器开启了RDB功能，那么服务器将对RDB文件进行载入：
- 如果服务器以**主服务器模式**运行，那么在载入RDB文件时，程序会对文件中保存的键进行检查，未过期的键会被载入到数据库中，而过期键则会被忽略，所以过期键对载入RDB文件的主服务器不会造成影响
- 如果服务器以**从服务器模式**运行，那么在载入RDB文件时，文件中保存的所有键，无论是否过期，都会被载入到数据库中。不过，因为主从服务器在进行数据同步的时候，从服务器的数据库就会被清空，所以一般来说，过期键对载入RDB文件的从服务器也不会造成影响

生成RDB文件的命令有两个，SAVE(阻塞)和BGSAVE(子进程并发进行处理)。

RDB文件的载入只有在服务器启动时自动执行，所以Redis并没有专门用于载入RDB文件的命令，只要Redis服务器在启动时检测到RDB文件存在，就会自动载入。

因为AOF文件的更新频率通常比RDB文件的更新频率高，所以：
- 如果服务器开启了AOF持久化功能，那么服务器优先使用AOF文件来还原数据库状态
- 只有在AOF持久化功能处于关闭状态时，服务器才会使用RDB文件来还原数据库状态

```C
struct redisServer{
  ...
  //配置多少秒内修改多少次数据库
  struct saveparam* saveparams;
  //修改计数器
  long long dirty;
  //上一次执行保存的时间
  time_t lastsave;
  ...
};
struct saveparam{
  //秒数
  time_t seconds;
  //修改数
  int changes;
};
```

#### RDB文件结构
一个完整RDB文件包含REDIS、db_version、databases、EOF、check_sum。
- RDB文件的最开头是REDIS部分，这个部分的长度为5字节，保存着“REDIS”五个字符。通过这五个字符，程序可以在载入文件时，快速检查所载入的文件是否RDB文件。
- db_version长度为4字节，它的值是一个字符串表示的整数，这个整数记录了RDB文件的版本号。
- databases部分包含者零个或任意多个数据库，以及各个数据库中的键值对数据。
- EOF常量的长度为1字节，这个常量标志着RDB文件正文内存的结束，当读入程序遇到这个值的时候，它知道所有数据库的所有键值对都已经载入完毕了。
- check_sum是一个8字节长的无符号整数，保存着一个检验和，这个校验和是程序通过对REDIS、db_version、databases、EOF四个部分的内容进行计算得出的。

每个非空数据库在RDB文件中都可以保存为SELECTDB、db_number、key_value_pairs三部分。
- SELECTDB常量的长度为1字节，当读入程序遇到这个值的时候，它知道接下来要读入的将是一个数据库号码。
- db_number保存着一个数据库号码，根据号码的大小不同，这个部分的长度可以是1字节、2字节或者5字节。当程序读入db_number部分后，服务器会调用SELECT命令，根据读入的数据库号码进行数据库切换，使得之后读入的键值对可以载入到正确的数据库中。
- key_value_pairs部分保存了数据库中的所有键值对数据，如果键值对带有过期时间，那么过期时间也会和键值对保存在一起。根据键值对的数量、类型、内容以及是否有过期时间等条件的不同，key_value_pairs部分的长度也会有所不同。


### AOF持久化
与RDB持久化通过保存数据库中的键值对来记录数据库状态不同，AOF持久化是通过保存Redis服务器所执行的写命令来记录数据库状态的。

如果数据库中的某个键已经过期，但它还没有被惰性删除或者定期删除，那么AOF文件不会因为这个过期键而产生任何影响。当过期键被惰性删除或者定期删除之后(数据库中)，程序会向AOF文件追加(append)一条DEL命令，来显式地记录该键已被删除。

和生成RDB文件时类似，在执行AOF重写的过程中，程序会对数据库中的键进行检查，已过期的键不会被保存到重写后的AOF文件中。

AOF持久化功能的实现可以分为命令追加、文件写入、文件同步三个步骤：
- 命令追加：当AOF持久化功能处于打开状态时，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器状态的aof buf缓冲区的末尾。
  ```C
    struct redisServer{
      ...
      //AOF缓冲区
      sds aof_buf;
      ...
    };
  ```

Redis读取AOF文件并还原数据库状态的详细步骤：
1. 创建一个不带网络连接的伪客户端：因为Redis的命令只能在客户端上下文中执行，而载入AOF文件时所使用的命令直接来源于AOF文件而不是网络连接，所以服务器使用了一个没有网络连接的伪客户端来执行AOF文件保存的写命令，伪客户端执行命令的效果和带网络连接的客户端执行命令的效果完全一样。
2. 从AOF文件中分析并读取出一条写命令。
3. 使用伪客户端执行被读出的写命令。
4. 一直执行步骤2和3，直到AOF文件中的所有写命令都被处理完毕为止。

#### AOF重写
Redis服务器可以创建一个新的AOF文件来替代现有的AOF文件，新旧两个AOF文件所保存的数据库状态相同，但新AOF文件不会包含任何浪费空间的冗余命令，所以新AOF文件的体积通常会比旧AOF文件的体积要小很多。

AOF文件重写并不需要对现有的AOF文件进行任何读取、分析或者写入操作，这个功能是通过读取服务器当前的数据库状态来实现的。

首先从数据库中读取键现在的值，然后用一条命令去记录键值对，代替之前记录这个键值对的多条命令，这就是AOF重写功能的实现原理。

因为子进程在进行AOF重写期间，服务器进程还需要继续处理命令请求，而新的命令可能会对现有的数据库状态进行修改，从而使得服务器当前的数据库状态和重写后的AOF文件所保存的数据库状态不一致。为此，Redis服务器设置了一个AOF重写缓冲区，这个缓冲区在服务器创建子进程之后开始使用，当Redis服务器执行完一个写命令之后，它会同时将这个写命令发送给AOF缓冲区和AOF重写缓冲区。

当子进程完成AOF重写工作之后，它会向父进程发送一个信号，父进程在接到该信号之后，会调用一个信号处理函数，并执行以下工作：
1. 将AOF重写缓冲区中的所有内容写入到新AOF文件中，这时新AOF文件所保存的数据库状态将和服务器当前的数据库状态一致。
2. 对新的AOF文件进行改名，原子地覆盖现有的AOF文件，完成新旧两个AOF文件的替换。

### 从服务器过期键的删除动作
- 主服务器在删除一个过期键之后，会显式地向所有从服务器发送一个DEL命令，告知从服务器删除这个过期键
- 从服务器在执行客户端发送的读命令时，即使碰到过期键也不会将过期键删除，而是继续像处理未过期的键一样来处理过期键
- 从服务器只有在接到主服务器发来的DEL命令之后，才会删除过期键

通过由主服务器来控制从服务器统一地删除过期键，可以保证主从服务器数据的一致性。

### 数据库通知
这个功能可以让客户端通过订阅给定的频道或者模式，来获知数据库中键的变化，以及数据库中命令的执行情况。

## 事件
Redis服务器是一个事件驱动程序，有文件事件和时间事件两种。

Redis服务器使用单线程单进程的方式来处理命令请求，并与多个客户端进行网络通信。

### 文件事件
Redis基于Reactor模式开发了自己的网络事件处理器——文件事件处理器：
- 文件事件处理器使用I/O多路复用程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器
- 当被监听的套接字准备好执行连接应答、读取、写入、关闭等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件

文件事件处理器由四部分组成：套接字、I/O多路复用程序、文件事件分派器以及事件处理器。

尽管多个文件事件可能会并发地出现，但I/O多路复用程序总是会将所有产生事件的套接字都放到一个队列里面，然后通过这个队列，以有序、同步、每次一个套接字的方式想文件事件分派器传送套接字。

文件事件分派器接收I/O多路复用程序传来的套接字，并根据套接字产生的事件的类型，调用相应的事件处理器。

### 时间事件
Redis的时间事件分为以下两类：
- 定时事件：让一段程序在指定的时间之后执行一次。
- 周期性事件：让一段程序在每隔指定时间就执行一次。

服务器将所有时间事件都放在一个无序链表中，每当时间事件执行器运行时，它就遍历整个链表，查找所有已到达的时间事件，并调用相应的事件处理器。所谓的无序，不是指链表不按ID排序，而是不按when属性的大小排序。

事件之间不会出现抢占，对文件事件和时间事件的处理都是同步、有序、原子地进行的。不管是文件事件的处理器，还是时间事件的处理器，它们都会尽可能地减少程序的阻塞事件，并在有需要时主动让出执行权，从而降低造成事件饥饿的可能性。

## 客户端
redisClient包含的状态信息：
- 客户端的套接字描述符
- 客户端的名字
- 客户端的标志值
- 指向客户端正在使用的数据库的指针，以及该数据库的号码
- 客户端当前要执行的命令、命令的参数、命令参数的个数，以及指向命令实现函数的指针
- 客户端的输入缓冲区和输出缓冲区
- 客户端的复制状态信息，以及进行复制所需的数据结构
- 客户端执行的BRPOP、BLPOP等列表阻塞命令时使用的数据结构
- 客户端的事务状态，以及执行WATCH命令时用到的数据结构
- 客户端执行发布与订阅功能时用到的数据结构
- 客户端的身份验证标志
- 客户端的创建时间，客户端和服务器最后一次通信的时间，以及客户端的输出缓冲区大小超出软性限制的时间

```C
struct redisServer{
  ...
  //一个链表，保存了所有客户端状态
  list* clients;
  ...
};
```

### 客户端的创建与关闭
服务器使用不同的方式来创建和关闭不同类型的客户端。

#### 普通客户端
如果客户端是通过网络连接与服务器进行连接的普通客户端，那么在客户端使用connect函数连接到服务器时，服务器就会调用连接事件处理器，为客户端创建相应的客户端状态，并将这个新的客户端状态添加到服务器状态结构clients链表的末尾。

#### Lua脚本的伪客户端
服务器会在初始化时创建负责执行Lua脚本中包含的Redis命令的伪客户端，并将这个伪客户端关联在服务器状态结构的lua_client属性中。lua_client伪客户端在服务器运行的整个生命期中会一直存在，只有服务器被关闭时，这个客户端才会被关闭。

#### AOF文件的伪客户端
服务器在载入AOF文件时，会创建用于执行AOF文件包含的Redis命令的伪客户端，并在载入完成之后，关闭这个伪客户端。

## 服务器
### 命令请求的执行过程
#### 发送命令请求
Redis服务器的命令请求来自Redis客户端，当用户在客户端中键入一个命令请求时，客户端会将这个命令请求转换成协议格式，然后通过连接到服务器的套接字，将协议格式的命令请求发送给服务器。

#### 读取命令请求
1. 读取套接字中协议格式的命令请求，并将其保存到客户端状态的输入缓冲区里面。
2. 对输入缓冲区中的命令请求进行分析，提取出命令请求中包含的命令参数，以及命令参数的个数，然后分别将参数和参数个数保存到客户端状态的argv和argc属性里。
3. 调用命令执行器，执行客户端指定的命令。

#### 命令执行器
1. 查找命令实现
2. 执行预备操作
3. 调用命令的实现函数
4. 执行后续工作

#### 处理SIGTERM信号
Redis会为服务器进程的SIGTERM信号关联处理器sigtermHandler函数，这个信号处理器负责在服务器接到SIGTERM信号时，打开服务器状态的shutdown_asap标识。serverCron根据shutdown_asap的值决定是否关闭服务器。若关闭服务器，则在关闭之前会进行RDB持久化操作，这也是服务器拦截SIGTERM信号的原因。

#### 管理数据库资源
serverCron函数每次执行都会调用databasesCron函数，这个函数会对服务器中的一部分数据库进行检查，删除其中的过期键，并在有需要时，对字典进行收缩操作。

#### 管理客户端资源
serverCron函数每次执行都调用clientsCron函数，clientsCron函数会对一定数量的客户端进行以下两个检查：
- 如果客户端与服务器之间的连接已经超时，那么程序释放这个客户端
- 如果客户端在上一次执行命令请求之后，输入缓冲区的大小超过了一定的长度，那么程序会释放客户端当前的输入缓冲区，并重新创建一个默认大小的输入缓冲区，从而防止客户端的输入缓冲区耗费了过多的内存。

#### 执行被延迟的BGREWRITEAOF
在服务器执行BGSAVE命令的期间，如果客户端向服务器发来BGREWRITEAOF命令，那么服务器会将BGREWRITEAOF命令的执行时间延迟到BGSAVE命令执行完毕之后。

## 初始化服务器
### 初始化服务器状态结构
初始化服务器的第一步就是创建一个struct redisServer类型的实例变量server作为服务器的状态，并为结构中的各个属性设置默认值。

## Sentinel(哨岗、哨兵)
Sentinel是Redis的高可用性(high availability)解决方案：由一个或多个Sentinel实例组成的Sentinel系统可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求。另外，Sentinel还会继续监视已下线的主服务器，并在它重新上线时，将它设置为新的主服务器的从服务器。

### 启动并初始化Sentinel
步骤：
1. 初始化服务器
2. 将普通Redis服务器使用的代码替换成Sentinel专用代码
3. 初始化Sentinel状态
4. 根据给定的配置文件，初始化Sentinel的监视主服务器列表
5. 创建连向主服务器的网络连接

```C
struct sentinelState{
  //当前纪元，用于实现故障转移
  uint64_t current_epoch;

  //保存了所有被这个sentinel监视的主服务器
  //字典的键是主服务器的名字
  //字典的值则是一个指向sentinelRedisInstance结构的指针
  dict* masters;

  //是否进入了TILT模式
  int tilt;

  //目前正在执行的脚本的数量
  int running_scripts;

  //进入TILT模式的时间
  mstime_t tilt_start_time;

  //最后一次执行时间处理器的时间
  mstime_t previous_time;

  //一个FIFO队列，包含了所有需要执行的用户脚本
  list* scripts_queue;
}sentinel;
```

```C
typedef struct sentinelRedisInstance{
  //标识值，记录了实例的类型，以及该实例的当前状态
  int flags;

  //实例的名字
  //主服务器的名字由用户在配置文件中设置
  //从服务器以及Sentinel的名字由Sentinel自动设置
  //格式为ip:port，例如“127.0.0.1:26379”
  char* name;

  //实例的运行ID
  char* runid;

  //配置纪元，用户实现故障转移
  uint64_t config_epoch;

  //实例的地址
  sentinelAddr* addr;

  //SENTINEL down-after-milliseconds选项设定的值
  //实例无响应多少毫秒之后才会被判断为主观下线
  mstime_t down_after_period;

  //SENTINEL monitor <master-name> <IP> <port> <quorum>选项中的quorum参数
  //判断这个实例为客观下线所需的支持投票数量
  int quorum;

  //SENTINEL parallel-syncs <master-name> <number>选项的值
  //在执行故障转移操作时，可以同时对新的主服务器进行同步的从服务器数量
  int parallel_syncs;

  //SENTINEL failover-timeout <master-name> <ms>选项的值
  //刷新故障迁移状态的最大时限
  mstime_t failover_timeout;
  ...
}sentinelRedisInstance;
```

### 故障转移
当主服务器下线后，Sentinel会选举出领头Sentinel，领头Sentinel将对已下线的主服务器执行故障转移操作，该操作包含以下三个步骤：
1. 在已下线主服务器属下的所有从服务器里面，挑选出一个从服务器，并将其转换为主服务器。
2. 让已下线主服务器属下的所有从服务器改为复制新的主服务器。
3. 将已下线主服务器设置为新的主服务器的从服务器，当这个旧的主服务器重新上线时，它就会称为新的主服务器的从服务器。

#### 筛选规则
领头Sentinel会将已下线主服务器的所有从服务器保存在一个列表里面，然后按照挑选主服务器的规则过滤：
1. 删除列表中所有处于下线或者断线状态的从服务器，这可以保证列表中剩余的从服务器都是正常在线的。
2. 删除列表中所有最近五秒内没有回复过领头Sentinel的INFO命令的从服务器，这可以保证列表中剩余的从服务器都是最近成功进行过通信的。
3. 删除所有与已下线主服务器连接断开超过down-after-milliseconds*10毫秒的从服务器：down-after-milliseconds选项指定了判断主服务器下线所需的时间，而删除断开时长超过down-after-milliseconds*10毫秒的从服务器，则可以保证列表中剩余的从服务器都没有过早地与主服务器断开连接，换句话说，列表中剩余的从服务器保存的数据都是比较新的。

之后，领头Sentinel将根据从服务器的优先级，对列表中剩余的从服务器进行排序，并选出其中优先级最高的从服务器。

如果有多个具有相同最高优先级的从服务器，那么领头Sentinel将按照从服务器的复制偏移量，对具有相同最高优先级的所有从服务器进行排序，并选出其中偏移量最大的从服务器(复制偏移量最大的从服务器就是保存这最新数据的从服务器)。

最后，如果有多个优先级最高、复制偏移量最大的从服务器，那么领头Sentinel将按照运行ID对这些从服务器进行排序，并选出其中运行ID最小的从服务器。

## 集群
Redis集群是Redis提供的分布式数据库方案，集群通过分片来进行数据共享，并提供复制和故障转移功能。

### 集群数据结构
clusterNode结构保存了一个节点的当前状态，每个节点都会使用一个clusterNode结构来记录自己的状态，并为集群里的其他节点都创建一个相应的clusterNode结构。
```C
struct clusterNode{
  //创建节点的时间
  mstime_t ctime;
  //节点的名字，由40个十六进制字符组成
  //例如68eef66d23...
  char name[REDIS_CLUSTER_NAMELEN];
  //节点标识
  //使用各种不同的标识值记录节点的角色(比如主节点或者从节点)
  //以及节点目前所处的状态(比如在线或者下线)
  int flags;
  //节点当前的配置纪元，用于实现故障转移
  uint64_t configEpoch;
  //节点的IP地址
  char ip[REDIS_IP_STR_LEN];
  //节点的端口号
  int port;
  //保存连接节点所需的有关信息
  clusterLink* link;
  ...
};
```

clusterLink结构保存了连接节点所需的有关信息，比如套接字描述符，输入缓冲区或输出缓冲区：
```C
typedef struct clusterLink{
  //连接的创建时间
  mstime_t ctime;
  //TCP套接字描述符
  int fd;
  //输出缓冲区，保存者等待发送给其他节点的信息
  sds sndbuf;
  //输入缓冲区，保存着从其他节点接收到的信息
  sds rcvbuf;
  //与这个连接相关联的节点，如果没有的话就为NULL
  struct clusterNode* node;
}clusterLink;
```
最后，每个节点都保存者一个clusterState结构，这个结构记录了在当前节点的视角下，集群目前所处的状态。
```C
typedef struct clusterState{
  //指向当前节点的指针
  clusterNode* myself;
  //集群当前的配置纪元，用于实现故障转移
  uint64_t currentEpoch;
  //集群当前的状态：是在线还是下线
  int state;
  //集群中至少处理着一个槽的节点的数量
  int size;
  //集群节点名单(包括myself节点)
  //字典的键为节点的名字，字典的值为节点对应的clusterNode结构
  dict* nodes;
  ...
}clusterState;
```

### 槽指派
Redis集群通过分片的方式来保存数据库中的键值对：集群的整个数据库被分为16384个槽(slot)，数据库中的每个键都属于这16384个槽的其中一个，集群中的每个节点可以处理0个或最多16384个槽。

当数据库中的16384个槽都有节点在处理时，集群处于上线状态；相反地，如果数据库中有任何一个槽没有得到处理，那么集群处于下线状态。

clusterNode结构的slots属性和numslot属性记录了节点复制处理哪些槽：
```C
struct clusterNode{
  ...
  unsigned char slots[16384/8];
  int numslots;
  ...
};
```
slots属性是一个二进制位数组，这个数组的长度为16384/8=2048个字节，共包含16384个二进制位。

clusterState结构中的slots数组记录了集群中所有16384个槽的指派信息：
```C
typedef struct clusterState{
  ...
  clusterNode* slots[16384];
  ...
}clusterState;
```
每个数组项都是一个指向clusterNode结构的指针。

### 重新分片
Redis集群的重新分片操作可以将任意数量已经指派给某个节点(源节点)的槽改为指派给另一个节点(目标节点)，并且相关槽所属的键值对也会从源节点被移动到目标节点。

重新分片操作可以在线(online)进行，在重新分片的过程中，集群不需要下线，并且源节点和目标节点都可以继续处理命令请求。

### ASK错误
在进行重新分片期间，源节点向目标节点迁移一个槽的过程中，可能会出现这样一种情况：属于被迁移槽的一部分键值对保存在源节点里面，而另一部分键值对则保存在目标节点里面。

当客户端向源节点发送一个与数据库键有关的命令，并且命令要处理的数据库键恰好就属于正在被迁移的槽时：
- 源节点会先在自己的数据库里面查找指定的键，如果找到的话，就直接执行客户端发送的命令。
- 相反地，如果源节点没能在自己的数据库里面找到指定的键，那么这个键有可能已经被迁移到了目标节点，源节点将向客户端返回一个ASK错误，指引客户端转向正在导入槽的目标节点，并再次发送之前想要执行的命令。

### 复制与故障转移
Redis集群中的节点分为主节点(master)和从节点(slave)，其中主节点用于处理槽，而从节点用于复制某个主节点，并在被复制的主节点下线时，代替下线主节点继续处理命令请求。

### 消息
一条消息由消息头和消息正文组成。

#### 消息头
节点发送的所有消息都由一个消息头包裹，消息头除了包含消息正文之外，还记录了消息发送者自身的一些消息，因为这些消息也会被消息接收者用到，所以严格来将，我们可以认为消息头本身也是消息的一部分。

```C
typedef struct{
  //消息的长度(包括这个消息头的长度和消息正文的长度)
  uint32_t totlen;
  //消息类型
  uint16_t type;
  //消息正文包含的节点信息数量
  //只在发送MEET、PING、PONG这三种Gossip协议消息时使用
  uint16_t count;
  //发送者所处的配置纪元
  uint16_t currentEpoch;
  //如果发送者是一个主节点，那么这里记录的是发送者的配置纪元
  //如果发送者是一个从节点，那么这里记录的是发送者正在复制的主节点的配置纪元
  uint16_t configEpoch;
  //发送者的名字(ID)
  char sender[REDIS_CLUSTER_NAMELEN];
  //发送者目前的槽指派信息
  unsigned char myslots[REDIS_CLUSTER_SLOTS/8];
  //如果发送者是一个从节点，那么这里记录的是发送者正在复制的主节点的名字
  //如果发送者是一个主节点，那么这里记录的是REDIS_NODE_NULL_NAME
  //(一个40字节长，值全为0的字节)
  char slaveof[REDIS_CLUSTER_NAMELEN];
  //发送者的端口号
  uint16_t port;
  //发送者的标识值
  uint16_t flags;
  //发送者所处集群的状态
  unsigned char state;
  //消息的正文
  union clusterMsgData data;
}clusterMsg;
```

## 发布与订阅
通过执行SUBSCRIBE命令，客户端可以订阅一个或多个频道，从而成为这些频道的订阅者：每当有其他客户端向被订阅的频道发送消息时，频道的所有订阅者都会收到这条消息。

除了订阅频道之外，客户端还可以通过执行PSUBSCRIBE命令订阅一个或多个模式，从而成为这些模式的订阅者：每当有其他客户端向某个频道发送消息时，消息不仅会被发送给这个频道的所有订阅者，它还会被发送给所有与这个频道相匹配的模式的订阅者。

### 频道的订阅与退订
Redis将所有频道的订阅关系都保存在服务器状态的pubsub_channels字典里面，这个字典的键是某个被订阅的频道，而键的值则是一个链表，链表里记录了所有订阅这个频道的客户端
```C
struct redisServer{
  ...
  //保存所有频道的订阅关系
  dict* pubsub_channels;
  ...
};
```

### 模式的订阅与退订
```C
struct redisServer{
  ...
  //保存所有模式订阅关系
  list* pubsub_patterns;
  ...
};
```

## 事务
每个Redis客户端都有自己的事务状态，这个事务状态保存在客户端状态的mstate属性里。

Redis的事务和传统的关系型数据库事务的最大区别在于，Redis不支持事务回滚机制(rollback)，即使事务队列中的某个命令在执行期间出现了错误，整个事务也会继续执行下去，直到将事务队列中的所有命令都执行完毕为止。

```C
typedef struct redisClient{
  ...
  //事务状态
  multiState mstate;
  ...
}redisClient;
```

### WATCH命令
WATCH命令是一个乐观锁，它可以在EXEC命令执行之前，监视任意数量的数据库键，并在EXEC命令执行时，检查被监视的键是否至少有一个已经被修改过了，如果是的话，服务器将拒绝执行事务，并向客户端返回代表事务执行失败的空回复。

### 事务的ACID性质
原子性(Atomicity)、一致性(Consistency)、隔离性(Isolation)、耐久性(Durability)。

#### 原子性
Redis的原子性仅仅作用于那些事务中的某个命令因为语法错误等明显可见的错误，这时整个事务都不会被执行。

#### 一致性
事务具有一致性指的是，如果数据库在执行事务之前是一致的，那么在事务执行之后，无论事务是否执行成功，数据库也应该仍然是一致的。

三个Redis事务可能出错的地方及处理方法：
1. 入队错误：
如果一个事务在入队命令的过程中，出现了命令不存在，或者命令的格式不正确等情况，那么Redis将拒绝执行这个事务。
2. 执行错误：
除了入队时可能发生错误以外，事务还可能在执行的过程中发生错误。
  - 执行过程中发生的错误都是一些不能在入队时被服务器发现的错误，这些错误只会在命令实际执行时被触发。
  - 即使在事务的执行过程中发生了错误，服务器也不会中断事务的执行，它会继续执行事务中余下的其他命令，并且已执行的命令(包括执行命令所产生的结果)不会被出错的命令影响。
3. 服务器停机：
如果Redis服务器在执行事务的过程中停机，那么根据服务器所使用的持久化模式，可能有以下情况出现
  - 如果服务器运行在无持久化的内存模式下，那么重启之后的数据库将是空白的，因此数据总是一致的。
  - 如果服务器运行在RDB模式下，那么在事务中途停机不会导致不一致性，因为服务器可以根据现有的RDB文件来恢复数据，从而将数据库还原到一个一致的状态。如果找不到可供使用的RDB文件，那么重启之后的数据库将是空白的，而空白数据库总是一致的。
  - 如果服务器运行在AOF模式下，那么在事务中途停机不会导致不一致性，因为服务器可以根据现有的AOF文件来恢复数据，从而将数据库还原到一个一致的状态。如果找不到可供使用的AOF文件，那么重启之后的数据库将是空白的，而空白数据库总是一致的。

#### 隔离性
各个事务之间不会互相影响，并且在并发状态下执行的事务和串行执行的事务产生的结果完全相同。

因为Redis使用单线程的方式来执行事务，并且服务器保证，在执行事务期间不会对事务进行中断，因此，Redis的事务总是以串行的方式运行的，并且事务也总是具有隔离性的。

#### 耐久性
因为Redis的事务不过是简单地用队列包裹起了一组Redis命令，Redis并没有为事务提供任何额外的持久化功能，所以Redis事物的耐久性由Redis所使用的持久化模式决定。
